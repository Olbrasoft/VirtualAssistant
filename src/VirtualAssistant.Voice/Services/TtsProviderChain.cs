using System.Collections.Concurrent;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using Olbrasoft.VirtualAssistant.Voice.Configuration;

namespace Olbrasoft.VirtualAssistant.Voice.Services;

/// <summary>
/// Status of a TTS provider in the circuit breaker system.
/// </summary>
public sealed record TtsProviderStatus(
    string Name,
    bool IsHealthy,
    DateTime? LastFailure,
    DateTime? NextRetryAt,
    int ConsecutiveFailures
);

/// <summary>
/// Interface for TTS provider chain with fallback support.
/// </summary>
public interface ITtsProviderChain
{
    /// <summary>
    /// Synthesizes text to audio using the provider chain.
    /// Tries each provider in order until one succeeds.
    /// </summary>
    Task<(byte[]? Audio, string? ProviderUsed)> SynthesizeAsync(
        string text,
        VoiceConfig config,
        string? sourceProfile = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the status of all configured providers.
    /// </summary>
    IReadOnlyList<TtsProviderStatus> GetProvidersStatus();

    /// <summary>
    /// Resets the circuit breaker state for a specific provider or all providers.
    /// </summary>
    void ResetCircuitBreaker(string? providerName = null);
}

/// <summary>
/// TTS provider chain with circuit breaker pattern.
/// Tries providers in configured order, remembers failures, and skips broken providers temporarily.
/// </summary>
public sealed class TtsProviderChain : ITtsProviderChain
{
    private readonly ILogger<TtsProviderChain> _logger;
    private readonly IReadOnlyDictionary<string, ITtsProvider> _providers;
    private readonly TtsProviderChainOptions _options;
    private readonly ConcurrentDictionary<string, ProviderState> _providerStates = new();

    private sealed class ProviderState
    {
        public bool IsHealthy { get; set; } = true;
        public DateTime? LastFailure { get; set; }
        public int ConsecutiveFailures { get; set; }
        public DateTime? NextRetryAt { get; set; }
    }

    public TtsProviderChain(
        ILogger<TtsProviderChain> logger,
        IEnumerable<ITtsProvider> providers,
        IOptions<TtsProviderChainOptions> options)
    {
        _logger = logger;
        _options = options.Value;

        // Build provider dictionary by name
        _providers = providers.ToDictionary(p => p.Name, p => p, StringComparer.OrdinalIgnoreCase);

        _logger.LogInformation("TTS provider chain initialized with {Count} providers: {Names}",
            _providers.Count, string.Join(", ", _providers.Keys));

        // Initialize states
        foreach (var name in _options.Providers)
        {
            _providerStates.TryAdd(name, new ProviderState());
        }
    }

    /// <inheritdoc />
    public async Task<(byte[]? Audio, string? ProviderUsed)> SynthesizeAsync(
        string text,
        VoiceConfig config,
        string? sourceProfile = null,
        CancellationToken cancellationToken = default)
    {
        foreach (var providerName in _options.Providers)
        {
            // Check if provider is registered
            if (!_providers.TryGetValue(providerName, out var provider))
            {
                _logger.LogWarning("Provider '{Name}' configured but not registered - skipping", providerName);
                continue;
            }

            // Check circuit breaker
            var state = _providerStates.GetOrAdd(providerName, _ => new ProviderState());

            if (!state.IsHealthy && state.NextRetryAt.HasValue && DateTime.UtcNow < state.NextRetryAt.Value)
            {
                _logger.LogDebug("Skipping provider '{Name}' - circuit breaker open until {RetryAt}",
                    providerName, state.NextRetryAt.Value.ToLocalTime());
                continue;
            }

            // Check if provider reports itself as available
            if (!provider.IsAvailable)
            {
                _logger.LogDebug("Skipping provider '{Name}' - reports not available", providerName);
                continue;
            }

            // Set source profile for Piper if applicable
            if (provider is PiperTtsProvider piperProvider)
            {
                piperProvider.SourceProfile = sourceProfile;
            }

            try
            {
                _logger.LogDebug("Trying provider '{Name}'...", providerName);

                var audio = await provider.GenerateAudioAsync(text, config, cancellationToken);

                if (audio != null && audio.Length > 0)
                {
                    // Success - mark provider as healthy
                    MarkHealthy(providerName);
                    _logger.LogInformation("TTS generated by '{Name}' ({Bytes} bytes)", providerName, audio.Length);
                    return (audio, providerName);
                }

                // Generation failed (returned null or empty)
                _logger.LogWarning("Provider '{Name}' returned no audio data", providerName);
                MarkFailed(providerName);
            }
            catch (OperationCanceledException)
            {
                throw; // Don't mark as failed on cancellation
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "Provider '{Name}' threw exception", providerName);
                MarkFailed(providerName);
            }
        }

        _logger.LogError("All TTS providers failed for text: {Text}", text.Length > 100 ? text[..100] + "..." : text);
        return (null, null);
    }

    /// <inheritdoc />
    public IReadOnlyList<TtsProviderStatus> GetProvidersStatus()
    {
        var statuses = new List<TtsProviderStatus>();

        foreach (var providerName in _options.Providers)
        {
            var state = _providerStates.GetOrAdd(providerName, _ => new ProviderState());

            statuses.Add(new TtsProviderStatus(
                Name: providerName,
                IsHealthy: state.IsHealthy,
                LastFailure: state.LastFailure,
                NextRetryAt: state.NextRetryAt,
                ConsecutiveFailures: state.ConsecutiveFailures
            ));
        }

        return statuses;
    }

    /// <inheritdoc />
    public void ResetCircuitBreaker(string? providerName = null)
    {
        if (providerName != null)
        {
            if (_providerStates.TryGetValue(providerName, out var state))
            {
                state.IsHealthy = true;
                state.ConsecutiveFailures = 0;
                state.LastFailure = null;
                state.NextRetryAt = null;
                _logger.LogInformation("Circuit breaker reset for provider '{Name}'", providerName);
            }
        }
        else
        {
            foreach (var kvp in _providerStates)
            {
                kvp.Value.IsHealthy = true;
                kvp.Value.ConsecutiveFailures = 0;
                kvp.Value.LastFailure = null;
                kvp.Value.NextRetryAt = null;
            }
            _logger.LogInformation("Circuit breaker reset for all providers");
        }
    }

    private void MarkHealthy(string providerName)
    {
        if (_providerStates.TryGetValue(providerName, out var state))
        {
            if (!state.IsHealthy)
            {
                _logger.LogInformation("Provider '{Name}' recovered after {Failures} consecutive failures",
                    providerName, state.ConsecutiveFailures);
            }

            state.IsHealthy = true;
            state.ConsecutiveFailures = 0;
            state.NextRetryAt = null;
        }
    }

    private void MarkFailed(string providerName)
    {
        var state = _providerStates.GetOrAdd(providerName, _ => new ProviderState());

        state.IsHealthy = false;
        state.LastFailure = DateTime.UtcNow;
        state.ConsecutiveFailures++;

        // Calculate cooldown
        var cooldownMinutes = _options.CircuitBreaker.CooldownMinutes;

        if (_options.CircuitBreaker.UseExponentialBackoff && state.ConsecutiveFailures > 1)
        {
            // Exponential backoff: 5, 10, 20, 40, ... up to max
            cooldownMinutes = (int)Math.Min(
                cooldownMinutes * Math.Pow(2, state.ConsecutiveFailures - 1),
                _options.CircuitBreaker.MaxCooldownMinutes
            );
        }

        state.NextRetryAt = DateTime.UtcNow.AddMinutes(cooldownMinutes);

        _logger.LogWarning(
            "Provider '{Name}' marked as failed ({Failures} consecutive). Cooldown: {Cooldown} min until {RetryAt}",
            providerName, state.ConsecutiveFailures, cooldownMinutes, state.NextRetryAt.Value.ToLocalTime());
    }
}
